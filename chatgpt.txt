這是我下面的程式碼, 你幫我看一下renderInsureanceDoc的地方,我透過UTIF來解我後端送過來的base64/tiff檔,並把它塞到canvas裡
如果就如圖所示,內容出現變型扭曲,我在猜有可能是rgba的地方設置有問題,要怎麼處理

  async function renderInsureanceDoc(doc: any): Promise<HTMLCanvasElement | null> {
    const base64 = doc.docSource;
    const base64Data = doc.docSource.replace(/^data:image\/png;base64,/, '');
    // renderTiffToCanvas(base64)


    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }


    return new Promise((resolve, reject) => {
      const canvas = document.createElement('canvas');
      if (canvas) {
        const ctx = canvas.getContext('2d');

        // 移除 MIME 類型前綴並解碼 Base64
        const base64Data = base64.replace(/^data:image\/tiff;base64,/, '');
        const binaryString = atob(base64Data);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }

        // 使用 UTIF.js 解碼 TIFF
        const ifds = UTIF.decode(bytes.buffer);
        const rgba = UTIF.toRGBA8(ifds[0]);
        const width = ifds[0].width;
        const height = ifds[0].height;
  
        
        const expectedLength = width * height * 4;
        if (rgba.length !== expectedLength) {
          console.error(`⚠️ RGBA 長度錯誤: ${rgba.length} !== ${expectedLength}`);
          return reject(new Error('❌ TIFF RGBA 長度與尺寸不符'));
        }
        
        // 設置 Canvas 尺寸
        canvas.width = width;
        canvas.height = height;
        // 將 RGBA 數據渲染到 Canvas
        const imageData = ctx.createImageData(width, height);

        imageData.data.set(rgba);
        ctx.putImageData(imageData, 0, 0);

      }
      // canvas.width = width;
      // canvas.height = height;
      resolve(canvas)

      // img.onload = () => {


      //   const ctx = canvas.getContext('2d');
      //   if (!ctx) return reject(new Error('無法取得 CanvasRenderingContext2D'));
      //   ctx.drawImage(img, 0, 0);

      //   const clickableRects: { x: number; y: number; width: number; height: number; xy: string, index: { pageIndex: number, sigIndex: number, type: number } }[] = [];

      //   if (stage.value !== 'preview') {
      //   }
      //   const highlights = (doc.signature || []).map(sig => {
      //     return {
      //       xy: sig.xy,
      //       signimg: sig.signimg,
      //       color: (sig.signimg) ? 'rgba(0, 0, 0, 0)' : '#eb949459',
      //       index: {
      //         pageIndex: doc.pageIndex,
      //         sigIndex: sig.sigIndex,
      //         type: sig.type
      //       }
      //     }
      //   });

      //   // 畫框
      //   highlights.forEach(({ xy, color, signimg, index }) => {
      //     const [x, y, width, height] = xy.split(',').map(Number);
      //     if (index.type === currentRole.value.type) {
      //       ctx.fillStyle = color;
      //       ctx.fillRect(x, y, width, height);
      //     }

      //     // ✅ 儲存可點擊區域
      //     clickableRects.push({ x, y, width, height, xy, index });

      //     const signImg = new Image();
      //     signImg.src = signimg;
      //     signImg.onload = () => {
      //       ctx.drawImage(signImg, x, y, width, height);
      //       //簽完名後，在背景上色
      //       // ctx.fillStyle = color;
      //       // ctx.fillRect(x, y, width, height);
      //     };
      //   });
      //   // ✅ 座標定位click
      //   canvas.addEventListener('click', (event) => {
      //     const rect = canvas.getBoundingClientRect();
      //     const scaleX = canvas.width / rect.width;
      //     const scaleY = canvas.height / rect.height;

      //     const mouseX = (event.clientX - rect.left) * scaleX;
      //     const mouseY = (event.clientY - rect.top) * scaleY;

      //     const clicked = clickableRects.find(({ x, y, width, height, index }) =>
      //       mouseX >= x && mouseX <= x + width && mouseY >= y && mouseY <= y + height
      //     );
      //     console.log(`clicked => `, clicked)


      //     if (!clicked) return
      //     if (clicked.index.type === currentRole.value.type) {
      //       currectClickSign.value = { ...clicked.index, width: clicked.width, height: clicked.height }
      //       openSignaturePadModal.value = true
      //     } else if (clicked.index.type !== currentRole.value.type) {
      //       alert(`請切換至${typeMapRole[clicked.index.type]}`);
      //     }
      //   });

      //   resolve(canvas); // ✅ 回傳 canvas

      // };
      // img.onerror = (err) => reject(err);
    });
  }