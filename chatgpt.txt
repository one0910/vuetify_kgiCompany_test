æˆ‘æ”¹å¥½äº†, ä½ çœ‹ä¸€ä¸‹æˆ‘ç›®å‰çš„æª”æ¡ˆ,ä½ èªç‚ºå¦‚ä½•, æœ‰å“ªéœ€è¦å†æ”¹é€²çš„å—?

æª”æ¡ˆä¸€ src\views\Front-stage\VButtonList.vue
<script setup>
import { onMounted, ref, watch, nextTick } from 'vue';
import { useInsureanceStore } from '@/stores/signature';
import SwitchSideBarRead from '@/components/signature/SwitchSideBar-Read.vue';
import CanvasViewer from '@/components/signature/CanvasViewer.vue';

const store = useInsureanceStore();
const scrollContainerRef = ref(null);
const canvasViewerRef = ref();
const maxHeight = ref(450);

function detectBottom(event) {
  if (!(event.target instanceof HTMLElement)) return;
  if (store.stage !== 'preview') return;
  const { scrollTop, scrollHeight, clientHeight } = event.target;
  const scrollPosition = scrollTop + clientHeight;

  let cumulativeHeight = 0;

  if (scrollHeight <= clientHeight + 1) return;

  store.currentDocs.forEach((doc, index) => {
    const pageHeight = doc.pageHeight || 0;
    const pageTop = cumulativeHeight;
    let pageBottom = cumulativeHeight + pageHeight;

    // âœ… åˆ¤æ–·ç›®å‰æ˜¯å¦åœ¨é€™ä¸€é çš„å¯è¦–ç¯„åœå…§
    const isInView = scrollTop >= pageTop && scrollTop < pageBottom;

    // âœ… åˆ¤æ–·æ˜¯å¦ç®—ã€Œå·²çœ‹å®Œã€
    const isRead = scrollPosition >= pageBottom && !doc.readComplete;
    //ç›®å‰æ»¾è¼ªåœ¨è©²é , ä¸”æ»‘åˆ°è©²é é åº•æ‰ç®—å·´å·²é–±è®€

    if (isRead && store.currentPage === index) {
      doc.readComplete = true;
      console.log(`âœ… ç¬¬ ${index + 1} é å·²é–±è®€å®Œç•¢`);
    }

    if (isInView) {
      if (store.currentPage !== index) {
        store.currentPage = index;
        console.log(`ğŸ‘‰ ç¾åœ¨ä½æ–¼ç¬¬ ${index + 1} é `);
      }
    }

    cumulativeHeight += pageHeight;
  });
}

function nextStep() {
  store.goToNextStage();
  nextTick(() => {
    canvasViewerRef.value?.renderAllCanvas();
  });
}

onMounted(() => {
  const el = scrollContainerRef.value?.$el;
  if (el instanceof HTMLElement) {
    el.addEventListener('scroll', detectBottom);
    maxHeight.value = screen.availHeight * 0.62;
    store.setScrollContainer(el);
  } else return;
});

watch(
  () => store.currentPage,
  () => {
    const el = scrollContainerRef.value?.$el;
    if (el instanceof HTMLElement) {
      el.removeEventListener('scroll', detectBottom);
    }
    requestAnimationFrame(() => {
      el.addEventListener('scroll', detectBottom);
    });
  }
);
</script>

<template>
  <v-container fluid="">
    <!-- åç¨±åˆ— & é æ•¸ -->
    <v-row>
      <v-col cols="1" class="pa-0 text-center align-self-center">
        <v-icon icon="mdi-chevron-left" color="grey-darken-1" size="30"></v-icon>
      </v-col>
      <v-col cols="11">
        <div class="d-flex bgPrimaryColor justify-space-between align-center">
          <p class="text-grey-darken-3">è¦ä¿äººåŒæ„æ›¸</p>
          <p class="text-grey-darken-3 pr-2">ç¸½é æ•¸10é </p>
        </div>
      </v-col>
    </v-row>
    <v-row>
      <!-- åˆ‡æ›é ç±¤æŒ‰éˆ• -->
      <v-col cols="1" class="pa-0">
        <SwitchSideBarRead />
      </v-col>

      <!-- ä¿æ›¸ã€åˆç´„æ›¸å…§å®¹ -->
      <v-col cols="11">
        <v-sheet class="bgPrimaryColor position-relative">
          <v-sheet
            ref="scrollContainerRef"
            class="d-flex justify-center bg-transparent overflow-auto"
            :max-height="maxHeight"
          >
            <v-sheet class="position-absolute top-0 left-0 w-100" color="transparent">
              <!-- <SignaturedNavbar /> -->
            </v-sheet>
            <div>
              <CanvasViewer ref="canvasViewerRef" :documents="store.currentDocs" />
            </div>
          </v-sheet>
        </v-sheet>

        <!-- ä¸‹ä¸€æ­¥æŒ‰éˆ• -->
        <v-layout row wrap class="justify-center mt-5">
          <v-btn
            density="comfortable"
            color="blue-darken-4"
            size="x-large"
            class="bg-white mr-5"
            variant="text"
            width="250"
            >å„²å­˜
          </v-btn>
          <v-btn
            density="comfortable"
            color="white"
            size="x-large"
            width="250"
            class="bg-blue-darken-4"
            :disabled="!store.eableNextButton"
            @click="nextStep"
            >ä¸‹ä¸€æ­¥
          </v-btn>
        </v-layout>
      </v-col>
    </v-row>
  </v-container>
</template>

<style lang="scss" scoped>
.bgPrimaryColor {
  background-color: #f2f6ff;
}

.step--completed {
  border: 2px solid rgba(var(--v-theme-primary), 1);
}

.step--editing {
  border: 2px solid rgba(var(--v-theme-secondary), 1);
}
</style>


æª”æ¡ˆäºŒ src\components\signature\CanvasViewer.vue
<script setup>
import { onMounted, ref, defineProps, nextTick, defineExpose } from 'vue';
import { useInsureanceStore } from '@/stores/signature';
const { documents } = defineProps(['documents']);
console.log(`documents => `, documents);

const store = useInsureanceStore();
const canvasRef = ref(null);
const isLoading = ref(false);

// é¦–æ¬¡æ›è¼‰æ™‚ä¹Ÿæ›´æ–°ä¸€æ¬¡ç•«å¸ƒ
async function renderAllCanvas() {
  if (!canvasRef.value) return;

  isLoading.value = true;
  canvasRef.value.innerHTML = '';
  for (let i = 0; i < documents.length; i++) {
    const canvas = await store.renderInsureanceDoc(documents[i]);
    if (canvas) {
      canvasRef.value.appendChild(canvas);
      await nextTick();
      await new Promise((resolve) => requestAnimationFrame(resolve));
      console.log(`canvasRef.value.innerHTML => `, canvasRef.value.innerHTML);
      const domHeight = canvas.offsetHeight;
      documents[i].pageHeight = domHeight;
      console.log(`ğŸ“ ç¬¬ ${i + 1} é  DOM é«˜åº¦ç‚º ${domHeight}px`);
    }
  }
  isLoading.value = false;
}

onMounted(async () => {
  await renderAllCanvas();
});

// watch(
//   () => store.stage,
//   async () => {
//     await nextTick(); // ç¢ºä¿ DOM å·²æ›´æ–°
//     await renderAllCanvas();
//   }
// );
defineExpose({
  renderAllCanvas
});
</script>

<template>
  <v-sheet class="d-flex justify-center align-center">
    <v-progress-circular
      color="grey-darken-1"
      indeterminate
      size="40"
      v-show="isLoading"
    ></v-progress-circular>
  </v-sheet>

  <div ref="canvasRef" v-show="!store.isLoading" class="canvas-container border-xl"></div>
</template>

<style lang="scss" scoped>
.canvas-container :deep(canvas) {
  max-width: 100%;
  border-bottom: 5px solid rgba(0, 0, 0, 0.2);
  display: block;
  margin: auto;
}
</style>

æª”æ¡ˆä¸‰ src\stores\signature.ts
import { defineStore } from 'pinia';
import { computed, ref } from 'vue';
import { fromArrayBuffer } from 'geotiff'

export const useInsureanceStore = defineStore('insureance', () => {
  const insureanceData = ref([
    {
      type: 'sign',
      insueranceId: Math.floor(Math.random() * 10000),
      title: 'è¦ä¿æ›¸1',
      signature: [
        {
          sinatureId: Math.floor(Math.random() * 10000),
          signatureTitle: 'è¦ä¿äººç°½å',
          cordinate: { x: 522, y: 266 },
          isSinged: false
        },
        {
          sinatureId: Math.floor(Math.random() * 10000),
          signatureTitle: 'è¢«ä¿éšªäººç°½å',
          cordinate: { x: 522, y: 346 },
          isSinged: true
        },
        {
          sinatureId: Math.floor(Math.random() * 10000),
          signatureTitle: 'æ³•å®šä»£ç†äººç°½å',
          cordinate: { x: 655, y: 443 },
          isSinged: false
        },
        {
          sinatureId: Math.floor(Math.random() * 10000),
          signatureTitle: 'é—œä¿‚',
          cordinate: { x: 1064, y: 449 },
          isSinged: false
        },
        {
          sinatureId: Math.floor(Math.random() * 10000),
          signatureTitle: 'è¢«ä¿éšªäººé…å¶ç°½å',
          cordinate: { x: 522, y: 224 },
          isSinged: false
        },
        {
          sinatureId: Math.floor(Math.random() * 10000),
          signatureTitle: 'è¢«ä¿éšªäººå­å¥³ç°½å',
          cordinate: { x: 522, y: 274 },
          isSinged: false
        }
      ],
      tiffUrl: '/ag_ieasy_confirm7.tiff?url',
      isSignaturing: true,
      readComplete: false,
      pageHeight: 0,
      allSignatureComplete: true
    },
    {
      type: 'sign',
      insueranceId: Math.floor(Math.random() * 10000),
      title: 'è¦ä¿æ›¸2',
      signature: [
        {
          sinatureId: Math.floor(Math.random() * 10000),
          signatureTitle: 'è¦ä¿äººåŒæ„åŒæŠ•ä¿',
          cordinate: { x: 100, y: 200 },
          isSinged: true
        }
      ],
      tiffUrl: '/ag_ieasy_confirm6.tiff?url',
      isSignaturing: true,
      readComplete: false,
      pageHeight: 0,
      allSignatureComplete: true
    },
    {
      type: 'sign',
      insueranceId: Math.floor(Math.random() * 10000),
      title: 'è¦ä¿æ›¸3',
      signature: [
        {
          sinatureId: Math.floor(Math.random() * 10000),
          signatureTitle: 'è¦ä¿äººåŒæ„åŒæŠ•ä¿',
          cordinate: { x: 100, y: 200 },
          isSinged: true
        }
      ],
      tiffUrl: '/ag_ieasy_confirm5.tiff?url',
      isSignaturing: true,
      readComplete: false,
      pageHeight: 0,
      allSignatureComplete: true
    },
    {
      type: 'sign',
      insueranceId: Math.floor(Math.random() * 10000),
      title: 'è¦ä¿æ›¸4',
      signature: [
        {
          sinatureId: Math.floor(Math.random() * 10000),
          signatureTitle: 'è¦ä¿äººåŒæ„åŒæŠ•ä¿',
          cordinate: { x: 100, y: 200 },
          isSinged: true
        }
      ],
      tiffUrl: '/ag_ieasy_confirm4.tiff?url',
      isSignaturing: true,
      readComplete: false,
      pageHeight: 0,
      allSignatureComplete: true
    },

  ]);

  type Stage = 'preview' | 'sign1' | 'sign2';
  const stage = ref<Stage>('preview');

  const currentDocs = computed(() => insureanceData.value);

  const eableNextButton = computed(() => {
    if (stage.value === 'preview') {
      return insureanceData.value.every(doc => doc.readComplete);
    }
    if (stage.value === 'sign1' || stage.value === 'sign2') {
      return insureanceData.value.every(doc => doc.allSignatureComplete);
    }
    return false;
  });

  const currentPage = ref(0);
  const renderedCanvas = ref(null);
  const isLoading = ref(true)
  const scrollContainerRef = ref(null);


  function setScrollContainer(el) {
    scrollContainerRef.value = el;
  }

  function goToNextStage() {
    if (stage.value === 'preview') {
      stage.value = 'sign1';
    } else if (stage.value === 'sign1') {
      stage.value = 'sign2';
    } else {
      console.log('âœ… æ‰€æœ‰æ­¥é©Ÿå®Œæˆ');
    }
    currentPage.value = 0;
  }


  async function renderInsureanceDoc(doc: any): Promise<HTMLCanvasElement | null> {
    const tiffUrl = doc.tiffUrl;

    try {
      isLoading.value = true
      const response = await fetch(tiffUrl)
      const arrayBuffer = await response.arrayBuffer()
      const tiff = await fromArrayBuffer(arrayBuffer)
      const image = await tiff.getImage();
      const raster = await image.readRasters({ interleave: true });
      const canvas = document.createElement('canvas');
      const width = image.getWidth();
      const height = image.getHeight();
      const ctx = canvas.getContext('2d');
      const imageData = ctx.createImageData(width, height);

      canvas.width = width;
      canvas.height = height;
      // salesDocPreview.value[page].pageHeight = height

      for (let i = 0; i < width * height; i++) {
        const r16 = raster[i * 4] as any;
        const g16 = raster[i * 4 + 1] as any;
        const b16 = raster[i * 4 + 2] as any;
        const a16 = raster[i * 4 + 3] as any;

        const r = (r16 * 255) / 65535;
        const g = (g16 * 255) / 65535;
        const b = (b16 * 255) / 65535;
        const a = (a16 * 255) / 65535;

        imageData.data[i * 4] = r;
        imageData.data[i * 4 + 1] = g;
        imageData.data[i * 4 + 2] = b;
        imageData.data[i * 4 + 3] = a;
      }

      ctx.putImageData(imageData, 0, 0);
      // renderedCanvas.value = canvas;
      isLoading.value = false
      return canvas;
    } catch (error) {
      isLoading.value = false
      console.error('æ¸²æŸ“ TIFF å¤±æ•—:', error);

      return null;
    }
  }


  async function switchPage({ index = currentPage.value, type = '' }) {
    isLoading.value = false
    if (type === 'last' && currentPage.value === 0) return;
    if (type === 'next' && currentPage.value === salesDocPreview.value.length - 1) return;

    // if (type === 'next') {
    //   currentPage.value++;
    // } else if (type === 'last') {
    //   currentPage.value--;
    // } else if (index !== currentPage.value) {
    // }
    currentPage.value = index;
    scrollToPage(currentPage.value);
    //éœ€å·²é–±è®€æ‰èƒ½è·³é 
    // if (salesDocPreview.value[currentPage.value].readComplete) {
    //   currentPage.value = index;
    //   scrollToPage(currentPage.value);
    // }
  }

  function scrollToPage(pageIndex) {

    const el = scrollContainerRef.value?.$el || scrollContainerRef.value;
    if (!(el instanceof HTMLElement)) return;

    let targetTop = 0;

    for (let i = 0; i < pageIndex; i++) {
      const doc = currentDocs.value[i];
      const height = (stage.value === 'preview' && 'pageHeight' in doc) ? doc.pageHeight : 0;
      targetTop += height;
    }

    el.scrollTo({
      top: targetTop,
      behavior: 'auto'
    });


    console.log(`ğŸ” æ»¾å‹•è‡³ç¬¬ ${pageIndex + 1} é ï¼Œä½ç½® ${targetTop}px`);
  }

  return {
    stage,
    insureanceData,
    currentPage,
    switchPage,
    renderInsureanceDoc,
    renderedCanvas,
    isLoading,
    scrollContainerRef,
    setScrollContainer,
    scrollToPage,
    eableNextButton,
    goToNextStage,
    currentDocs
  };
});
