ç¶“éä½ çš„å»ºè­°,æˆ‘å·²å°‡SignatureRoleTypeç”¨refå°è£, ä¸éæˆ‘ç¾åœ¨æœ‰å€‹å•é¡Œæ˜¯åœ¨doc.pageHeightçš„éƒ¨ä»½,ç¶“éä½ çš„æ”¹å¯«,å®ƒçš„å€¼ä¸€ç›´éƒ½æ˜¯0,
é€™å€‹å€¼æ¯”è¼ƒç‰¹åˆ¥,å®ƒéœ€è¦åœ¨canvasè¢«appendåˆ°DOMä¹‹å¾Œ,æ‰æœ‰è¾¦æ³•è¨˜ç®—å®ƒçš„offsetHeightçš„é«˜åº¦
ä½ çœ‹ä¸€ä¸‹src\components\signature\CanvasViewer.vueé€™æ”¯ç¨‹å¼è£¡çš„ 
const domHeight = canvas.offsetHeight;
documents[i].pageHeight = domHeight;
é€™å…©è¡Œç¨‹å¼ç¢¼,å®ƒå°±æ˜¯æˆ‘èªªçš„canvasçš„offsetHeight,å®ƒå¾Œä¾†æœƒå†å¯«å…¥åˆ°storeè£¡çš„currentDocsè£¡çš„pageHeight,
ä½†ç”±æ–¼æˆ‘ä¹‹å‰çš„SignatureRoleTypeçš„å¯«æ³•æ˜¯çš„æ˜¯ç”¨insureanceDataç„¶å¾Œé€écomputedå°è£æˆçš„,æ‰€ä»¥å®ƒçš„è³‡æ–™åœ¨è®Šæ›´æ™‚,éƒ½æœƒéŸ¿æ‡‰å¼çš„è‡ªå‹•æ›´æ–°
æ‰€ä»¥SignatureRoleTypeçš„pageHeightå°±å¯ä»¥æ­£ç¢ºå–å¾—, é‚£ä¾æˆ‘ç›®å‰çš„ç‹€æ³,è¦æ€éº¼è§£? æ˜¯å¦éœ€è¦å°‡insureanceDataæ”¹å¯«æˆgetã€setçš„æ–¹? é‚„æ˜¯ä½ æœ‰å…¶ä»–æ–¹æ³•?

src\stores\signature2.ts
import { defineStore } from 'pinia';
import { computed, ref } from 'vue';
import { fromArrayBuffer } from 'geotiff'
import { getSignatureDoc } from '@/service/documentSignature';
import { typeMapRole } from '@/utility/roleMap';

export const useInsureanceStore = defineStore('insureance', () => {
  type Stage = 'preview' | 'sign1' | 'sign2';
  type SignStatus = 'unselected' | 'unsigned' | 'signed';
  const insureanceData = ref<any[]>([]);
  const stage = ref<Stage>('preview');
  const currentRole = ref({ index: 0, type: 0 })
  const currentPage = ref(0);
  const renderedCanvas = ref(null);
  const isLoading = ref(true)
  const scrollContainerRef = ref(null);
  const signatureButton = ref<any[]>([]);
  const currentDocs = computed(() => insureanceData.value);
  const originalStatusMap = ref<Record<number, { status: SignStatus; type: number }>>({});
  const navbarHeight = ref<number>(0)
  const signatureRoleType = ref<any[]>([])


  //æ˜¯å¦å•Ÿç”¨ä¸‹ä¸€æ­¥çš„æŒ‰éˆ•
  const enableNextButton = computed(() => {
    if (stage.value === 'preview') {
      return insureanceData.value.every(doc => doc.readComplete);
    }
    if (stage.value === 'sign1') {
      return insureanceData.value.every(doc =>
        (doc.signature || []).every(sig => sig.signimg?.trim())
      );
    }
    return false;
  });


  // å¾Œç«¯å‚³ä¾†çš„è³‡æ–™åšå¥½æ•´ç†å¾Œæ”¾è‡³insureanceData
  async function fetchInsureanceDocs() {
    const data = await getSignatureDoc();
    originalStatusMap.value = {};
    if (!data) return;

    const { form, sign } = data;

    // å°‡ sign æ ¹æ“š form åˆ†çµ„
    const groupedSignatures = sign.reduce((acc: Record<string, any[]>, sig) => {
      if (!acc[sig.form]) {
        acc[sig.form] = [];
      }
      acc[sig.form].push({
        ...sig,
        type: parseInt(sig.type),
        sigIndex: acc[sig.form].length
      });
      return acc;
    }, {});

    // å°‡ form çµåˆå°æ‡‰çš„ signature
    const transformedData = await Promise.all(
      form.map(async (item, index) => {
        const documentHeight = await getImageHeight(item.docSource);
        originalStatusMap.value[index] = {
          status: 'unselected',
          type: 9
        }
        return {
          ...item,
          pageIndex: index,
          signature: groupedSignatures[item.form] || [],
          pageHeight: 0,
          documentHeight,
        };
      })
    );

    insureanceData.value = transformedData;
    buildSignatureRoleType()
    setFirstPageCurrentRole()
  }


  function setFirstPageCurrentRole() {
    const first = signatureRoleType.value[0];
    currentRole.value = first ? { index: 0, type: first.type } : { index: 0, type: 0 };
    switchRoleToButton(0)
  }

  //å–å¾—æ¯å€‹åœ–ç‰‡çš„é«˜åº¦
  function getImageHeight(src: string): Promise<number> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.src = src;
      img.onload = () => resolve(img.height);
      img.onerror = reject;
    });
  }

  //è§’è‰²åˆ—æŒ‰éˆ•
  function buildSignatureRoleType() {
    const roleMap = new Map<number, Record<number, { sigIndex: number, pageIndex: number, documentHeight: number, pageHeight: number, signId: string; signimg: string; xy: string }>>();

    for (const doc of  .value) {
      console.log(`doc.pageHeight => `, doc.pageHeight)
      const pageIndex = doc.pageIndex;
      for (const sig of doc.signature || []) {
        const type = parseInt(sig.type);
        if (!roleMap.has(type)) {
          roleMap.set(type, {});
        }

        // å¦‚æœé€™é ä¸­å·²æœ‰è©²è§’è‰²ï¼Œè·³éé¿å…è¦†è“‹ï¼ˆæ ¹æ“šä½ è³‡æ–™çµæ§‹ï¼Œæ¯é ä¸€å€‹typeå°æ‡‰ä¸€ç­†ç°½åï¼‰
        if (!roleMap.get(type)![pageIndex]) {
          roleMap.get(type)![pageIndex] = {
            signId: sig.signId,
            signimg: sig.signimg,
            sigIndex: sig.sigIndex,
            xy: sig.xy,
            documentHeight: doc.documentHeight,
            pageHeight: doc.pageHeight,
            pageIndex: doc.pageIndex,
          };
        }
      }
    }

    // âœ… ç”¢ç”Ÿå®Œæ•´çš„ signatureRoleType é™£åˆ—ï¼Œä¸¦ç”Ÿæˆ buttonStatus
    const result = Array.from(roleMap.entries()).map(([type, pageMap]) => {
      const buttonStatus: SignStatus[] = [];
      const totalPages = insureanceData.value.length;

      for (let i = 0; i < totalPages; i++) {
        if (pageMap[i]) {
          buttonStatus.push(pageMap[i].signimg?.trim() ? 'signed' : 'unsigned');
        } else {
          buttonStatus.push('unselected');
        }
      }

      return {
        type,
        name: typeMapRole[type] || `æœªçŸ¥è§’è‰² ${type}`,
        pageData: pageMap,
        allSignedComplete: false,
        buttonStatus
      };
    });
    signatureRoleType.value = result;
  }

  function switchRoleToButton(index: number) {
    const docs = currentDocs.value;
    const role = signatureRoleType.value[index];

    // æ ¹æ“šå°æ‡‰è§’è‰²çš„ buttonStatusï¼Œé€é æ›´æ–° currentDocs ä¸­çš„ buttonStatus
    role.buttonStatus.forEach((status, pageIndex) => {
      if (docs[pageIndex]) {
        docs[pageIndex].buttonStatus = status;
      }
    });
  }


  //å¼•ç”¨Canvasçµ„ä»¶çš„åƒè€ƒ
  function setScrollContainer(el: any) {
    scrollContainerRef.value = el;
  }


  async function renderInsureanceDoc(doc: any): Promise<HTMLCanvasElement | null> {
    const base64 = doc.docSource;

    return new Promise((resolve, reject) => {
      const img = new Image();
      img.src = base64;
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;

        const ctx = canvas.getContext('2d');
        if (!ctx) return reject(new Error('ç„¡æ³•å–å¾— CanvasRenderingContext2D'));
        ctx.drawImage(img, 0, 0);


        if (stage.value !== 'preview') {
        }
        const highlights = (doc.signature || []).map(sig => ({
          xy: sig.xy,
          color: '#eb949459'
        }));

        // ç•«æ¡†
        highlights.forEach(({ xy, color }) => {
          const [x, y, width, height] = xy.split(',').map(Number);
          ctx.fillStyle = color;
          ctx.fillRect(x, y, width, height);
        });

        canvas.addEventListener('mousemove', (event) => {
          const rect = canvas.getBoundingClientRect(); // å–å¾—ç•«å¸ƒç›¸å°ä½ç½®
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          const mouseX = (event.clientX - rect.left) * scaleX;
          const mouseY = (event.clientY - rect.top) * scaleY;

          // console.log(`ğŸ–±ï¸ æ»‘é¼ åœ¨ canvas åº§æ¨™: (${mouseX.toFixed(2)}, ${mouseY.toFixed(2)})`);
        });
        resolve(canvas); // âœ… å›å‚³ canvas

      };
      img.onerror = (err) => reject(err);
    });
  }


  //æ›é ç±¤åˆ‡æ›åŠŸèƒ½
  async function switchPage({ index = currentPage.value, type = '' }) {
    isLoading.value = false
    currentPage.value = index;
    scrollToPage(currentPage.value);
    //éœ€å·²é–±è®€æ‰èƒ½è·³é 
    // if (salesDocPreview.value[currentPage.value].readComplete) {
    //   currentPage.value = index;
    //   scrollToPage(currentPage.value);
    // }
  }

  function checkRoleSignAll(roleIndex: number): boolean {
    const role = signatureRoleType.value[roleIndex];
    if (!role || !role.pageData) return false;

    return Object.values(role.pageData).every((item: any) => item.signimg?.trim());
  }

  //æ»‘è¡Œæ»¾è¼ªç§»å‹•åˆ°è©²é 
  function scrollToPage(pageIndex: number) {

    const el = scrollContainerRef.value?.$el || scrollContainerRef.value;
    if (!(el instanceof HTMLElement)) return;

    let targetTop = 0;

    for (let i = 0; i < pageIndex; i++) {
      const doc = currentDocs.value[i];
      const height = (stage.value === 'preview' && 'pageHeight' in doc) ? doc.pageHeight : 0;
      targetTop += height;
    }

    el.scrollTo({
      top: targetTop,
      behavior: 'auto'
    });


    console.log(`ğŸ” æ»¾å‹•è‡³ç¬¬ ${pageIndex + 1} é ï¼Œä½ç½® ${targetTop}px`);
  }

  //ä¸Šã€ä¸‹æŒ‰éˆ•åˆ‡æ›
  function switchSignButton({ index = currentPage.value, type = '' }) {
    const role = signatureRoleType.value[currentRole.value.index];
    console.log(`role => `, role)
    const pageKeys = Object.keys(role.pageData).map(k => Number(k)).sort((a, b) => a - b);
    const currentIdx = pageKeys.findIndex(k => k === currentPage.value);

    if (type === 'next') {
      const nextIdx = currentIdx + 1;

      if (nextIdx < pageKeys.length) {
        const nextKey = pageKeys[nextIdx];
        currentPage.value = nextKey;
        const sig = role.pageData[nextKey];
        console.log(`â¡ï¸ ä¸‹ä¸€é  index: ${nextKey}, xy: ${sig.xy}`);
        console.log(`nextKey => `, nextKey)
        skipToSignPosition(nextKey.toString(), 'button')
      } else {
        const isRoleAllSignCheck = checkRoleSignAll(currentRole.value.index);
        if (!isRoleAllSignCheck) {
          alert('æ‚¨å°šæœªç°½ç½²å®Œç•¢');
          return;
        }
        const nextRoleIdx = currentRole.value.index + 1;
        if (nextRoleIdx < signatureRoleType.value.length) {
          currentRole.value = {
            index: nextRoleIdx,
            type: signatureRoleType.value[nextRoleIdx].type
          };
          const firstKey = Number(Object.keys(signatureRoleType.value[nextRoleIdx].pageData)[0]);
          currentPage.value = firstKey;
          console.log(`firstKey => `, firstKey)
          role.allSignedComplete
          switchRoleToButton(nextRoleIdx)
          skipToSignPosition(firstKey.toString(), 'button')
          console.log(`â¡ï¸ åˆ‡æ›è§’è‰²è‡³ index: ${firstKey}`);

        }
      }
    } else if (type === 'last') {
      const prevIdx = currentIdx - 1;
      if (prevIdx >= 0) {
        const prevKey = pageKeys[prevIdx];
        currentPage.value = prevKey;
        const sig = role.pageData[prevKey];
        console.log(`â¬…ï¸ ä¸Šä¸€é  index: ${prevKey}`);
        skipToSignPosition(prevKey.toString(), 'button')
      } else {
        const prevRoleIdx = currentRole.value.index - 1;
        if (prevRoleIdx >= 0) {
          currentRole.value = {
            index: prevRoleIdx,
            type: signatureRoleType.value[prevRoleIdx].type
          };
          const lastKeys = Object.keys(signatureRoleType.value[prevRoleIdx].pageData).map(k => Number(k)).sort((a, b) => a - b);
          const lastKey = lastKeys[lastKeys.length - 1];
          currentPage.value = lastKey;
          switchRoleToButton(prevRoleIdx)
          skipToSignPosition(lastKey.toString(), 'button')
          console.log(`â¬…ï¸ åˆ‡æ›è§’è‰²è‡³ index: ${lastKey}`);
        }
      }
    } else {
      currentPage.value = index;
    }
  }


  //è·³åˆ°ç°½åçš„ä½ç½®
  function skipToSignPosition(positionIndex: string = '', type: string) {
    const el = scrollContainerRef.value?.$el || scrollContainerRef.value;
    if (!(el instanceof HTMLElement)) return;
    const roleIndex = currentRole.value.index
    const target = signatureRoleType.value[roleIndex].pageData[positionIndex];
    const [x, y, width, height] = target.xy.split(',').map(Number);
    const { pageIndex, pageHeight, documentHeight } = target;

    let targetTop = 0;

    if (type === 'button') {
      // âœ… æ­£ç¢ºåœ°å¾ currentDocs è¨ˆç®—å‰é¢é é¢çš„ç¸½é«˜åº¦
      const accumulatedHeight = (pageHeight || 0) * (pageIndex || 0);

      const yOffset = (pageHeight / documentHeight) * y;

      targetTop = accumulatedHeight + yOffset - navbarHeight.value;


      // console.log('ğŸ“Œ scrollTo è©³ç´°è³‡è¨Šï¼š');
      console.log('pageIndex:', pageIndex);
      console.log(`pageHeight => `, pageHeight)
      console.log(`documentHeight => `, documentHeight)
      console.log('accumulatedHeight:', accumulatedHeight);
      console.log('yOffset:', yOffset);
      console.log('navbarHeight:', navbarHeight.value);
      console.log('targetTop:', targetTop);
    }

    el.scrollTo({
      top: targetTop,
      behavior: 'instant',
    });
  }



  return {
    stage,
    navbarHeight,
    insureanceData,
    currentPage,
    currentRole,
    originalStatusMap,
    switchPage,
    skipToSignPosition,
    switchSignButton,
    switchRoleToButton,
    renderInsureanceDoc,
    renderedCanvas,
    isLoading,
    scrollContainerRef,
    setScrollContainer,
    scrollToPage,
    enableNextButton,
    currentDocs,
    fetchInsureanceDocs,
    signatureRoleType,
    checkRoleSignAll
  };
});

src\components\signature\CanvasViewer.vue
<script setup>
import { onMounted, ref, nextTick, defineExpose } from 'vue';
import { useInsureanceStore } from '@/stores/signature';
import Loading from '@/components/Loading.vue';
const { documents } = defineProps(['documents']);

const store = useInsureanceStore();
const canvasRef = ref(null);
const isLoading = ref(false);

// é¦–æ¬¡æ›è¼‰æ™‚ä¹Ÿæ›´æ–°ä¸€æ¬¡ç•«å¸ƒ
async function renderAllCanvas() {
  isLoading.value = true;
  if (!canvasRef.value) return;

  canvasRef.value.innerHTML = '';
  for (let i = 0; i < documents.length; i++) {
    const canvas = await store.renderInsureanceDoc(documents[i], i);
    if (canvas) {
      canvasRef.value.appendChild(canvas);
      await nextTick();

      await new Promise((resolve) => requestAnimationFrame(resolve));
      const domHeight = canvas.offsetHeight;
      documents[i].pageHeight = domHeight;
    }
  }
  //æ‰€æœ‰çš„canvasæ¸²æŸ“å®Œç•¢å¾Œï¼Œæ•´å€‹é é¢çš„é«˜åº¦æ‰æœƒæ˜¯å°çš„ï¼Œé€™å€‹æ™‚å€™å†ä¾†åŸ·è¡ŒscrollToï¼Œæ‰æœƒæœ‰ä½œç”¨ï¼Œä¹Ÿæ‰èƒ½åˆ°æ­£ç¢ºçš„ä½ç½®
  if (store.stage === 'sign1') {
    store.skipToSignPosition('0', 'button');
  }
  isLoading.value = false;
}

onMounted(async () => {
  await renderAllCanvas();
});

defineExpose({
  renderAllCanvas
});
</script>

<template>
  <Loading v-show="isLoading" />

  <div
    ref="canvasRef"
    class="canvas-container border-xl"
    :class="isLoading ? 'opacity-0' : 'opacity-1'"
  ></div>
</template>

<style lang="scss" scoped>
.canvas-container :deep(canvas) {
  max-width: 100%;
  border-bottom: 5px solid rgba(0, 0, 0, 0.2);
  display: block;
  margin: auto;
}
</style>

